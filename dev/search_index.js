var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#WeightedData.L2Loss-Tuple{WeightedValue, Number}","page":"API","title":"WeightedData.L2Loss","text":"(loss::L2Loss)((; data, precision)::WeightedValue, model::Number)\n\nCalculate the loss (negloglikelihood) for a weighted data point under a Gaussian model.\n\nArguments\n\ndata: The observed value in the weighted point.\nprecision: The precision (inverse variance) associated with the observation.\nmodel: The predicted value from the model.\n\nReturns\n\nThe loss contribution: (data - model)^2 * precision / 2\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedArray","page":"API","title":"WeightedData.WeightedArray","text":"WeightedArray{T,N}\n\nN-dimensional array of WeightedValue{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#WeightedData.WeightedArray-Union{Tuple{N}, Tuple{T2}, Tuple{AbstractArray{<:Union{Missing, Real}, N}, AbstractArray{T2, N}}} where {T2<:Real, N}","page":"API","title":"WeightedData.WeightedArray","text":"WeightedArray(values::AbstractArray{<:Union{Missing,Real},N}, precision::AbstractArray{<:Real,N})\n\nBuild a WeightedArray while handling invalid entries.\n\nAny position where values is missing/NaN or precision is NaN is replaced by (0, 0) in the resulting weighted array.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedArray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}}} where {T<:Real, N}","page":"API","title":"WeightedData.WeightedArray","text":"WeightedArray(values::AbstractArray{T,N}, precision::AbstractArray{T,N})\n\nBuild a weighted array from value and precision arrays of the same shape.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedValue","page":"API","title":"WeightedData.WeightedValue","text":"WeightedValue{T<:Real} <: Number\n\nValue with associated precision (inverse variance).\n\nWeightedValue stores a numeric value and a non-negative precision. It is the scalar building block used throughout WeightedData.jl.\n\nConstructor behavior:\n\nprecision < 0 throws an error;\nnon-finite input value is converted to (0, 0).\n\nFields\n\nvalue::T: The value\nprecision::T: The precision (must be non-negative)\n\nExample\n\nx = WeightedValue(1.0, 0.5)  # value 1.0 with precision 0.5\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:+-Tuple{WeightedValue, WeightedValue}","page":"API","title":"Base.:+","text":"+(A::WeightedValue, B::WeightedValue)\n\nAdd two weighted values.\n\nThe resulting value is A.value + B.value. The resulting precision is computed using standard independent-error propagation:\n\np = 1 / (1/A.precision + 1/B.precision)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, WeightedValue}","page":"API","title":"Base.show","text":"show(io::IO, x::WeightedValue)\n\nPretty-print x as value ± uncertainty, with uncertainty computed as 1/sqrt(precision). The number of significant digits in the uncertainty can be controlled with IO context key :error_digits (default: 2).\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.flagbadpix!-Union{Tuple{N}, Tuple{T1}, Tuple{ZippedArrays.ZippedArray{WeightedValue{T1}, N, 2, I, Tuple{A, B}} where {A<:AbstractArray{T1, N}, B<:AbstractArray{T1, N}, I}, Union{BitArray{N}, AbstractArray{Bool, N}}}} where {T1, N}","page":"API","title":"WeightedData.flagbadpix!","text":"flagbadpix!(data::WeightedArray, badpix)\n\nIn-place version of flagbadpix for WeightedArray.\n\nAll positions where badpix is true are set to (0, 0).\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_precision-Tuple{AbstractArray{<:WeightedValue}}","page":"API","title":"WeightedData.get_precision","text":"get_precision(x::AbstractArray{<:WeightedValue})\n\nExtract an array with the precisions of each WeightedValue element.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_precision-Tuple{WeightedValue}","page":"API","title":"WeightedData.get_precision","text":"get_precision(x::WeightedValue)\n\nReturn the precision (inverse variance) stored in x.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_value-Tuple{AbstractArray{<:WeightedValue}}","page":"API","title":"WeightedData.get_value","text":"get_value(x::AbstractArray{<:WeightedValue})\n\nExtract an array with the values of each WeightedValue element.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_value-Tuple{WeightedValue}","page":"API","title":"WeightedData.get_value","text":"get_value(x::WeightedValue)\n\nReturn the numeric value stored in x.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_weight-Tuple{WeightedValue, Any}","page":"API","title":"WeightedData.get_weight","text":"get_weight(data::WeightedValue, model; loss=L2Loss())\n\nCalculate the equivalent weight for a given the loss function for IRLS.\n\nArguments\n\ndata: The observed value in the weighted point.\nmodel: The predicted value from the model.\nloss: The loss function to use (default: L2 loss).\n\nReturns\n\nThe equivalent weight.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.likelihood-Tuple{AbstractArray{<:WeightedValue}, AbstractArray}","page":"API","title":"WeightedData.likelihood","text":"likelihood(data::AbstractArray{<:WeightedValue}, model::AbstractArray; loss=L2Loss())\n\nCalculate the likelihood for an array of weighted data points.\n\nArguments\n\ndata: The observed values in the weighted points.\nmodel: The predicted values from the model.\nloss: The loss function to use (default: L2 loss).\n\nReturns\n\nThe neg log likelihood value.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.likelihood-Tuple{WeightedValue, Any}","page":"API","title":"WeightedData.likelihood","text":"likelihood(data::WeightedValue, model; loss=L2Loss())\n\nCalculate the likelihood for a weighted data point.\n\nArguments\n\ndata: The observed value in the weighted point.\nmodel: The predicted value from the model.\nloss: The loss function to use (default: L2 loss).\n\nReturns\n\nThe neg log likelihood value.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.weightedmean-Tuple{WeightedValue, WeightedValue}","page":"API","title":"WeightedData.weightedmean","text":"weightedmean(A::WeightedValue, B::WeightedValue)\n\nCompute the precision-weighted mean of two WeightedValue objects.\n\nFor A = (v₁, p₁) and B = (v₂, p₂), this returns:\n\nvalue: (p₁*v₁ + p₂*v₂) / (p₁ + p₂)\nprecision: p₁ + p₂\n\nExample\n\nx = WeightedValue(1.0, 0.5)\ny = WeightedValue(2.0, 1.5)\nz = weightedmean(x, y)  # WeightedValue(1.75, 2.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.weightedmean-Union{Tuple{AbstractArray{WeightedValue{T}}}, Tuple{T}} where T","page":"API","title":"WeightedData.weightedmean","text":"weightedmean(A::AbstractArray{WeightedValue}; dims=:)\n\nCompute a precision-weighted mean over all elements (dims=:) or along the specified dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.weightedmean-Union{Tuple{NTuple{N, WeightedValue}}, Tuple{N}} where N","page":"API","title":"WeightedData.weightedmean","text":"weightedmean(A::NTuple{N,WeightedValue}) where {N}\n\nCompute the precision-weighted mean of a tuple of WeightedValue objects.\n\nThis method reduces the tuple with pairwise weightedmean.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.weightedmean-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{WeightedValue{T1}}, AbstractArray{WeightedValue{T2}}}} where {T1, T2}","page":"API","title":"WeightedData.weightedmean","text":"weightedmean(A::AbstractArray{WeightedValue}, B::AbstractArray{WeightedValue})\n\nElement-wise precision-weighted mean of two weighted arrays with matching shape.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainRulesCore.rrule-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{typeof(likelihood), ScaledL2Loss, AbstractArray{WeightedValue{T1}, N}, AbstractArray{T2, N}}} where {T1, T2, N}","page":"API","title":"ChainRulesCore.rrule","text":"ChainRulesCore.rrule(::typeof(likelihood), ::ScaledL2Loss, weighteddata, model)\n\nCustom reverse-mode rule for likelihood(::ScaledL2Loss, weighteddata::AbstractArray{<:WeightedValue}, model).\n\nThe pullback returns gradients with respect to model. The derivative through the optimal scaling factor α is intentionally ignored (treated as stationary at optimum).\n\nArguments\n\nweighteddata: weighted observations\nmodel: model values with the same shape as weighteddata\n\nReturns\n\nscalar objective value\npullback that propagates gradients to model\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainRulesCore.rrule-Union{Tuple{N}, Tuple{T}, Tuple{typeof(likelihood), WeightedData.L2Loss, AbstractArray{WeightedValue{T}, N}, AbstractArray{T, N}}} where {T, N}","page":"API","title":"ChainRulesCore.rrule","text":"ChainRulesCore.rrule(::typeof(likelihood), ::L2Loss, data, model)\n\nCustom reverse-mode rule for likelihood(::L2Loss, data::AbstractArray{<:WeightedValue}, model).\n\nArguments\n\ndata: weighted observations\nmodel: model values with the same shape as data\n\nReturns\n\nscalar objective value\npullback that propagates gradients to model\n\n\n\n\n\n","category":"method"},{"location":"api/#Measurements.Measurement-Tuple{WeightedValue}","page":"API","title":"Measurements.Measurement","text":"Measurement(x::WeightedValue)\n\nConvert WeightedValue to Measurements.Measurement.\n\nArguments\n\nx::WeightedValue: A WeightedValue with value and precision\n\nReturns\n\nA Measurements.Measurement with:\n\nvalue = get_value(x)\nuncertainty = 1 / sqrt(get_precision(x))\n\nNotes\n\nUncertainty is the standard deviation.\n\nExample\n\nusing Measurements, WeightedData\nw = WeightedValue(1.0, 100.0)  # value = 1.0, precision = 100.0\nm = Measurement(w)  # 1.0 ± 0.1\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedValue-Tuple{Measurement}","page":"API","title":"WeightedData.WeightedValue","text":"WeightedValue(x::Measurements.Measurement)\n\nConvert a Measurements.Measurement to WeightedValue.\n\nArguments\n\nx::Measurements.Measurement: value with uncertainty\n\nReturns\n\nA WeightedValue with:\n\nvalue = Measurements.value(x)\nprecision = Measurements.uncertainty(x)^(-2)\n\nNotes\n\nPrecision is the inverse variance.\n\nExample\n\nusing Measurements, WeightedData\nm = 1.0 ± 0.1  # Measurement with value 1.0 and uncertainty 0.1\nw = WeightedValue(m)  # WeightedValue(1.0, 100.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_weight-Tuple{LossFunction, AbstractArray{<:WeightedValue}, AbstractArray}","page":"API","title":"WeightedData.get_weight","text":"get_weight(loss::LossFunction, data::AbstractArray{<:WeightedValue}, model::AbstractArray)\n\nCompute IRLS weights element-wise for arrays of weighted observations. data and model must have the same shape.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_weight-Tuple{LossFunction, WeightedValue, Number}","page":"API","title":"WeightedData.get_weight","text":"get_weight(loss::LossFunction, data::WeightedValue, model::Number)\n\nCompute IRLS weight for a single weighted observation.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.likelihood-Tuple{LossFunction, AbstractArray{<:WeightedValue}, AbstractArray}","page":"API","title":"WeightedData.likelihood","text":"likelihood(loss::LossFunction, data::AbstractArray{<:WeightedValue}, model::AbstractArray)\n\nCompute robust loss for arrays of weighted observations. data and model must have the same shape.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.likelihood-Tuple{LossFunction, WeightedValue, Number}","page":"API","title":"WeightedData.likelihood","text":"likelihood(loss::LossFunction, data::WeightedValue, model::Number)\n\nCompute robust loss contribution for a single weighted observation.\n\nResidual is defined as: r = sqrt(get_precision(data)) * (model - get_value(data)) and the returned value is rho(loss, r).\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Type-Union{Tuple{WeightedValue}, Tuple{T}} where T<:(Union{Uncertain.ValueAny{T, TU}, Uncertain.ValueNumber{T, TU}, Uncertain.ValueReal{T, TU}} where {T, TU})","page":"API","title":"Core.Type","text":"T(x::WeightedValue) where T <: Uncertain.Value\n\nConvert WeightedValue to an Uncertain.Value subtype.\n\nArguments\n\nx::WeightedValue: A WeightedValue with value and precision\n\nReturns\n\nAn uncertain value with:\n\nvalue = get_value(x)\nuncertainty = 1 / sqrt(get_precision(x))\n\nNotes\n\nUncertainty is the standard deviation.\n\nExample\n\nusing Uncertain, WeightedData\nw = WeightedValue(1.0, 100.0)  # value = 1.0, precision = 100.0\nu = Uncertain.Value(w)  # Uncertain.Value(1.0, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedValue-Tuple{Union{Uncertain.ValueAny{T, TU}, Uncertain.ValueNumber{T, TU}, Uncertain.ValueReal{T, TU}} where {T, TU}}","page":"API","title":"WeightedData.WeightedValue","text":"WeightedValue(x::Uncertain.Value)\n\nConvert an Uncertain.Value to WeightedValue.\n\nArguments\n\nx::Uncertain.Value: value with uncertainty\n\nReturns\n\nA WeightedValue with:\n\nvalue = Uncertain.value(x)\nprecision = Uncertain.uncertainty(x)^(-2)\n\nNotes\n\nPrecision is the inverse variance.\n\nExample\n\nusing Uncertain, WeightedData\nu = Uncertain.Value(1.0, 0.1)  # value = 1.0, uncertainty = 0.1\nw = WeightedValue(u)  # WeightedValue(1.0, 100.0)\n\n\n\n\n\n","category":"method"},{"location":"#WeightedData","page":"Home","title":"WeightedData","text":"WeightedData.jl provides weighted numeric containers and likelihood utilities.","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"using WeightedData\n\nx = WeightedValue(1.0, 0.5)\ny = WeightedValue(2.0, 0.2)\nz = weightedmean(x, y)\n\ndata = WeightedArray([1.0, 1.0], [2.0, 0.5])\nmodel = [1.0, 1.5]\nll = likelihood(data, model)","category":"section"},{"location":"#Extensions","page":"Home","title":"Extensions","text":"WeightedData.jl provides optional extensions that are activated automatically when the corresponding package is loaded:\n\nChainRulesCore → custom rrule methods for likelihood\nMeasurements → conversion between Measurement and WeightedValue\nRobustModels → robust likelihood and get_weight methods\nUncertain → conversion between Uncertain.Value and WeightedValue\n\nSee the API page for extension method docstrings.\n\n","category":"section"}]
}
