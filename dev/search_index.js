var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#WeightedData.L2Loss-Tuple{WeightedValue, Number}","page":"API","title":"WeightedData.L2Loss","text":"(loss::L2Loss)((; data, precision)::WeightedValue, model::Number)\n\nCalculate the loss (negloglikelihood) for a weighted data point under a Gaussian model.\n\nArguments\n\ndata: The observed value in the weighted point.\nprecision: The precision (inverse variance) associated with the observation.\nmodel: The predicted value from the model.\n\nReturns\n\nThe loss contribution: (data - model)^2 * precision / 2\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedArray","page":"API","title":"WeightedData.WeightedArray","text":"WeightedArray{T,N}\n\nN-dimensional array of WeightedValue{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#WeightedData.WeightedArray-Union{Tuple{N}, Tuple{T2}, Tuple{AbstractArray{<:Union{Missing, Real}, N}, AbstractArray{T2, N}}} where {T2<:Real, N}","page":"API","title":"WeightedData.WeightedArray","text":"WeightedArray(values::AbstractArray{<:Union{Missing,Real},N}, precision::AbstractArray{<:Real,N})\n\nBuild a WeightedArray while handling invalid entries.\n\nAny position where values is missing/NaN or precision is NaN is replaced by (0, 0) in the resulting weighted array.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedArray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}}} where {T<:Real, N}","page":"API","title":"WeightedData.WeightedArray","text":"WeightedArray(values::AbstractArray{T,N}, precision::AbstractArray{T,N})\n\nBuild a weighted array from value and precision arrays of the same shape.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedValue","page":"API","title":"WeightedData.WeightedValue","text":"WeightedValue{T<:Real} <: Number\n\nValue with associated precision (inverse variance).\n\nWeightedValue stores a numeric value and a non-negative precision. It is the scalar building block used throughout WeightedData.jl.\n\nConstructor behavior:\n\nprecision < 0 throws an error;\nnon-finite input value is converted to (0, 0).\n\nFields\n\nvalue::T: The value\nprecision::T: The precision (must be non-negative)\n\nExample\n\nx = WeightedValue(1.0, 0.5)  # value 1.0 with precision 0.5\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:+-Tuple{WeightedValue, WeightedValue}","page":"API","title":"Base.:+","text":"+(A::WeightedValue, B::WeightedValue)\n\nAdd two weighted values.\n\nThe resulting value is A.value + B.value. The resulting precision is computed using standard independent-error propagation:\n\np = 1 / (1/A.precision + 1/B.precision)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, WeightedValue}","page":"API","title":"Base.show","text":"show(io::IO, x::WeightedValue)\n\nPretty-print x as value ± uncertainty, with uncertainty computed as 1/sqrt(precision). The number of significant digits in the uncertainty can be controlled with IO context key :error_digits (default: 2).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Union{Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, WeightedValue{T}}} where T","page":"API","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", x::WeightedValue)\n\nPretty-print x in non-compact mode with explicit type information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.mean-Tuple{Tuple{Vararg{WeightedValue}}}","page":"API","title":"Statistics.mean","text":"mean(iterable; dims=:)\n\nCompute a precision-weighted mean from an iterable of WeightedValue.\n\nWith dims = : (default), returns a scalar WeightedValue.\nWith dims set to one or more dimensions, returns a WeightedArray.\n\niterable must be non-empty, have WeightedValue elements, and expose an element type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.mean-Tuple{WeightedValue, Vararg{WeightedValue}}","page":"API","title":"Statistics.mean","text":"mean(A::WeightedValue, B::Vararg{WeightedValue})\n\nCompute the precision-weighted mean of one or more scalar weighted values.\n\nEquivalent to reducing the inputs with the same precision-weighted averaging rule used for tuples/iterables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.mean-Union{Tuple{N}, Tuple{S2}, Tuple{S1}, Tuple{AbstractArray{S1, N}, AbstractArray{S2, N}, Vararg{Any}}} where {S1<:WeightedValue, S2<:WeightedValue, N}","page":"API","title":"Statistics.mean","text":"mean(A::AbstractArray{<:WeightedValue, N}, B::AbstractArray{<:WeightedValue, N}, C...) where {N}\n\nElement-wise precision-weighted mean of weighted arrays with matching shape.\n\nmean(A, B, ...) returns an element-wise weighted mean.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.std-Tuple{AbstractArray{<:WeightedValue}}","page":"API","title":"Statistics.std","text":"std(x::AbstractArray{<:WeightedValue})\n\nReturn the element-wise standard deviation array of x, defined as:\n\nstd(x) = sqrt.(var(x)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.std-Tuple{WeightedValue}","page":"API","title":"Statistics.std","text":"std(x::WeightedValue)\n\nReturn the standard deviation of x, defined as:\n\nstd(x) = sqrt(var(x)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.var-Tuple{AbstractArray{<:WeightedValue}}","page":"API","title":"Statistics.var","text":"var(x::AbstractArray{<:WeightedValue})\n\nReturn the element-wise variance array of x, defined as the inverse precision at each position:\n\nvar(x) = 1 ./ get_precision(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.var-Tuple{WeightedValue}","page":"API","title":"Statistics.var","text":"var(x::WeightedValue)\n\nReturn the variance of x, defined as the inverse precision:\n\nvar(x) = 1 / get_precision(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.loglikelihood-Tuple{AbstractArray{<:WeightedValue}, AbstractArray}","page":"API","title":"StatsAPI.loglikelihood","text":"loglikelihood(data::AbstractArray{<:WeightedValue}, model::AbstractArray; loss=L2Loss())\n\nCalculate the negative log-likelihood for an array of weighted data points.\n\nArguments\n\ndata: The observed values in the weighted points.\nmodel: The predicted values from the model.\nloss: The loss function to use (default: L2 loss).\n\nReturns\n\nThe neg log likelihood value.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.loglikelihood-Tuple{WeightedValue, Any}","page":"API","title":"StatsAPI.loglikelihood","text":"loglikelihood(data::WeightedValue, model; loss=L2Loss())\n\nCalculate the negative log-likelihood for a weighted data point.\n\nArguments\n\ndata: The observed value in the weighted point.\nmodel: The predicted value from the model.\nloss: The loss function to use (default: L2 loss).\n\nReturns\n\nThe neg log likelihood value.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.flagbaddata!-Union{Tuple{N}, Tuple{T1}, Tuple{ZippedArrays.ZippedArray{WeightedValue{T1}, N, 2, I, Tuple{A, B}} where {A<:AbstractArray{T1, N}, B<:AbstractArray{T1, N}, I}, Union{BitArray{N}, AbstractArray{Bool, N}}}} where {T1, N}","page":"API","title":"WeightedData.flagbaddata!","text":"flagbaddata!(data::WeightedArray, badmask)\n\nIn-place version of flagbaddata for WeightedArray.\n\nAll positions where badmask is true are set to (0, 0).\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_precision-Tuple{AbstractArray{<:WeightedValue}}","page":"API","title":"WeightedData.get_precision","text":"get_precision(x::AbstractArray{<:WeightedValue})\n\nExtract an array with the precisions of each WeightedValue element.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_precision-Tuple{WeightedValue}","page":"API","title":"WeightedData.get_precision","text":"get_precision(x::WeightedValue)\n\nReturn the precision (inverse variance) stored in x.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_value-Tuple{AbstractArray{<:WeightedValue}}","page":"API","title":"WeightedData.get_value","text":"get_value(x::AbstractArray{<:WeightedValue})\n\nExtract an array with the values of each WeightedValue element.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_value-Tuple{WeightedValue}","page":"API","title":"WeightedData.get_value","text":"get_value(x::WeightedValue)\n\nReturn the numeric value stored in x.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_weight-Tuple{WeightedValue, Any}","page":"API","title":"WeightedData.get_weight","text":"get_weight(data::WeightedValue, model; loss=L2Loss())\n\nCalculate the equivalent weight for a given the loss function for IRLS.\n\nArguments\n\ndata: The observed value in the weighted point.\nmodel: The predicted value from the model.\nloss: The loss function to use (default: L2 loss).\n\nReturns\n\nThe equivalent weight.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainRulesCore.rrule-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{typeof(loglikelihood), WeightedData.ScaledL2Loss, AbstractArray{WeightedValue{T1}, N}, AbstractArray{T2, N}}} where {T1, T2, N}","page":"API","title":"ChainRulesCore.rrule","text":"ChainRulesCore.rrule(::typeof(loglikelihood), ::ScaledL2Loss, weighteddata, model)\n\nCustom reverse-mode rule for loglikelihood(::ScaledL2Loss, weighteddata::AbstractArray{<:WeightedValue}, model).\n\nThe pullback returns gradients with respect to model. The derivative through the optimal scaling factor α is intentionally ignored (treated as stationary at optimum).\n\nArguments\n\nweighteddata: weighted observations\nmodel: model values with the same shape as weighteddata\n\nReturns\n\nscalar objective value\npullback that propagates gradients to model\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainRulesCore.rrule-Union{Tuple{N}, Tuple{T}, Tuple{typeof(loglikelihood), WeightedData.L2Loss, AbstractArray{WeightedValue{T}, N}, AbstractArray{T, N}}} where {T, N}","page":"API","title":"ChainRulesCore.rrule","text":"ChainRulesCore.rrule(::typeof(loglikelihood), ::L2Loss, data, model)\n\nCustom reverse-mode rule for loglikelihood(::L2Loss, data::AbstractArray{<:WeightedValue}, model).\n\nArguments\n\ndata: weighted observations\nmodel: model values with the same shape as data\n\nReturns\n\nscalar objective value\npullback that propagates gradients to model\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedValue-Tuple{Measurement}","page":"API","title":"WeightedData.WeightedValue","text":"WeightedValue(x::Measurements.Measurement)\n\nConvert a Measurements.Measurement to WeightedValue.\n\nArguments\n\nx::Measurements.Measurement: value with uncertainty\n\nReturns\n\nA WeightedValue with:\n\nvalue = Measurements.value(x)\nprecision = Measurements.uncertainty(x)^(-2)\n\nNotes\n\nPrecision is the inverse variance.\n\nExample\n\nusing Measurements, WeightedData\nm = 1.0 ± 0.1  # Measurement with value 1.0 and uncertainty 0.1\nw = WeightedValue(m)  # WeightedValue(1.0, 100.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Measurements.measurement-Tuple{WeightedValue}","page":"API","title":"Measurements.measurement","text":"Measurement(x::WeightedValue)\n\nConvert WeightedValue to Measurements.Measurement.\n\nArguments\n\nx::WeightedValue: A WeightedValue with value and precision\n\nReturns\n\nA Measurements.Measurement with:\n\nvalue = get_value(x)\nuncertainty = 1 / sqrt(get_precision(x))\n\nNotes\n\nUncertainty is the standard deviation.\n\nExample\n\nusing Measurements, WeightedData\nw = WeightedValue(1.0, 100.0)  # value = 1.0, precision = 100.0\nm = Measurement(w)  # 1.0 ± 0.1\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedArray-Union{Tuple{ZippedArrays.ZippedArray{UnivariateStatistic{T, K, W}, N, K2, I, A} where {I, A, K2}}, Tuple{W}, Tuple{K}, Tuple{N}, Tuple{T}} where {T, N, K, W}","page":"API","title":"WeightedData.WeightedArray","text":"WeightedArray(x::IndependentStatistic{T, N, K, W}) where {T, N, K, W}\n\nConvert an independent online statistic array to a WeightedArray.\n\nThe returned values are mean(x) and element-wise precisions inv.(var(x)). At least two moments (K ≥ 2) are required so that the variance is available.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedValue-Union{Tuple{UnivariateStatistic{T, K}}, Tuple{K}, Tuple{T}} where {T, K}","page":"API","title":"WeightedData.WeightedValue","text":"WeightedValue(x::UnivariateStatistic{T, K}) where {T, K}\n\nConvert a univariate online statistic to a WeightedValue.\n\nThe returned value is mean(x) and the returned precision is inv(var(x)). At least two moments (K ≥ 2) are required so that the variance is available.\n\n\n\n\n\n","category":"method"},{"location":"api/#RobustModels.workingweights-Tuple{LossFunction, AbstractArray{<:WeightedValue}, AbstractArray}","page":"API","title":"RobustModels.workingweights","text":"workingweights(loss::LossFunction, data::AbstractArray{<:WeightedValue}, model::AbstractArray)\n\nCompute the working weights for a given loss function, weighted data, and model.\n\nThis function calculates the weights used in iterative weighted least squares algorithms by delegating to get_weight with the specified loss function, data, and model parameters.\n\nArguments\n\nloss::LossFunction: The loss function defining the weighting scheme\ndata::AbstractArray{<:WeightedValue}: Array of weighted data points\nmodel::AbstractArray: Model parameters or predictions\n\nReturns\n\nArray of working weights corresponding to the input data\n\nSee Also\n\nget_weight\nRobustModels.LossFunction\nWeightedValue\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_weight-Tuple{LossFunction, AbstractArray{<:WeightedValue}, AbstractArray}","page":"API","title":"WeightedData.get_weight","text":"get_weight(loss::LossFunction, data::AbstractArray{<:WeightedValue}, model::AbstractArray)\n\nCompute IRLS weights element-wise for arrays of weighted observations. data and model must have the same shape.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.get_weight-Tuple{LossFunction, WeightedValue, Number}","page":"API","title":"WeightedData.get_weight","text":"get_weight(loss::LossFunction, data::WeightedValue, model::Number)\n\nCompute IRLS weight for a single weighted observation.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.likelihood-Tuple{LossFunction, AbstractArray{<:WeightedValue}, AbstractArray}","page":"API","title":"WeightedData.likelihood","text":"likelihood(loss::LossFunction, data::AbstractArray{<:WeightedValue}, model::AbstractArray)\n\nCompute robust loss for arrays of weighted observations. data and model must have the same shape.\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.likelihood-Tuple{LossFunction, WeightedValue, Number}","page":"API","title":"WeightedData.likelihood","text":"likelihood(loss::LossFunction, data::WeightedValue, model::Number)\n\nCompute robust loss contribution for a single weighted observation.\n\nResidual is defined as: r = sqrt(get_precision(data)) * (model - get_value(data)) and the returned value is rho(loss, r).\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Type-Union{Tuple{WeightedValue}, Tuple{T}} where T<:(Union{Uncertain.ValueAny{T, TU}, Uncertain.ValueNumber{T, TU}, Uncertain.ValueReal{T, TU}} where {T, TU})","page":"API","title":"Core.Type","text":"T(x::WeightedValue) where T <: Uncertain.Value\n\nConvert WeightedValue to an Uncertain.Value subtype.\n\nArguments\n\nx::WeightedValue: A WeightedValue with value and precision\n\nReturns\n\nAn uncertain value with:\n\nvalue = get_value(x)\nuncertainty = 1 / sqrt(get_precision(x))\n\nNotes\n\nUncertainty is the standard deviation.\n\nExample\n\nusing Uncertain, WeightedData\nw = WeightedValue(1.0, 100.0)  # value = 1.0, precision = 100.0\nu = Uncertain.Value(w)  # Uncertain.Value(1.0, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"api/#WeightedData.WeightedValue-Tuple{Union{Uncertain.ValueAny{T, TU}, Uncertain.ValueNumber{T, TU}, Uncertain.ValueReal{T, TU}} where {T, TU}}","page":"API","title":"WeightedData.WeightedValue","text":"WeightedValue(x::Uncertain.Value)\n\nConvert an Uncertain.Value to WeightedValue.\n\nArguments\n\nx::Uncertain.Value: value with uncertainty\n\nReturns\n\nA WeightedValue with:\n\nvalue = Uncertain.value(x)\nprecision = Uncertain.uncertainty(x)^(-2)\n\nNotes\n\nPrecision is the inverse variance.\n\nExample\n\nusing Uncertain, WeightedData\nu = Uncertain.Value(1.0, 0.1)  # value = 1.0, uncertainty = 0.1\nw = WeightedValue(u)  # WeightedValue(1.0, 100.0)\n\n\n\n\n\n","category":"method"},{"location":"#WeightedData","page":"Home","title":"WeightedData","text":"WeightedData.jl provides weighted numeric containers and likelihood utilities for uncertainty-aware estimation and model fitting.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"WeightedData\")","category":"section"},{"location":"#Why-WeightedData?","page":"Home","title":"Why WeightedData?","text":"Keep values and their precisions together in a single, type-stable container.\nCompute weighted statistics while handling missing or invalid measurements.\nEvaluate likelihoods directly from weighted observations and model predictions.","category":"section"},{"location":"#Core-concepts","page":"Home","title":"Core concepts","text":"WeightedValue(value, precision) stores a scalar observation and its precision.\nWeightedArray(values, precisions) stores array-valued observations and per-entry precisions.\nPrecision is interpreted as inverse variance, w = 1  sigma^2.","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"using WeightedData\nimport Statistics: mean, var, std\nimport StatsAPI: loglikelihood\n\nx = WeightedValue(1.0, 0.5)\ny = WeightedValue(2.0, 0.2)\nz = mean(x, y)\nvx = var(x)\nsx = std(x)\n\ndata = WeightedArray([1.0, 1.0], [2.0, 0.5])\nmodel = [1.0, 1.5]\nll = loglikelihood(data, model)","category":"section"},{"location":"#Common-workflows","page":"Home","title":"Common workflows","text":"using WeightedData\nimport Statistics: mean, var, std\nimport WeightedData: flagbaddata!\n\n# Weighted means from two observations\na = WeightedValue(1.2, 2.0)\nb = WeightedValue(0.8, 1.0)\nm = mean(a, b)\nva = var(a)\n\n# Global weighted mean over a weighted array\nwa = WeightedArray([1.0, 2.0, 3.0], [1.0, 1.0, 0.5])\nmg = mean(wa)\nvg = var(wa)\nsg = std(wa)\n\n# Mark invalid entries before analysis\nw = WeightedArray([1.0, NaN, 3.0], [1.0, 1.0, 1.0])\nflagbaddata!(w)\n\n# Likelihood of model predictions\nobs = WeightedArray([2.0, 1.0], [4.0, 0.5])\npred = [1.8, 1.2]\nℓ = loglikelihood(obs, pred)","category":"section"},{"location":"#Extensions","page":"Home","title":"Extensions","text":"WeightedData.jl provides optional extensions that are activated automatically when the corresponding package is loaded:\n\nRobustModels → robust loglikelihood taking any Losses defined in RobustModels\nOnlineSampleStatistics → extract sample mean and sample variance of a series of observation to build a WeightedData (WeightedValue or WeightedArray)\nChainRulesCore → custom rrule methods for loglikelihood\nMeasurements → conversion between Measurement and WeightedValue\nUncertain → conversion between Uncertain.Value and WeightedValue\n\nSee API Reference for full method docstrings, including extension methods.","category":"section"}]
}
